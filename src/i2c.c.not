#include <avr/interrupt.h>
#include <avr/io.h>
#include <stdio.h>

#define I2C_DEBUG

// Global declarations

#define I2C_BUFF_SIZE 32
#define KB_BUFF_SIZE 8
#define DISP_BUFF_SIZE 4
#define RTC_SLA 0xa2       // Including R/W bit

volatile uint8_t I2C_write_buffer[I2C_BUFF_SIZE];
volatile uint8_t I2C_read_buffer[I2C_BUFF_SIZE];

volatile uint8_t RTC_new_time_avail;
volatile uint8_t RTC_clock_on;
volatile uint8_t RTC_alarm_on;  // XXX
volatile uint8_t RTC_alarm_signaled;  // XXX

volatile uint8_t DISP_value[DISP_BUFF_SIZE];
volatile uint8_t DISP_mark;
volatile uint8_t DISP_mux;

volatile uint8_t KB_FIFO[KB_BUFF_SIZE];
volatile uint8_t KB_write_ptr;
volatile uint8_t KB_read_ptr;
volatile uint8_t KB_queue_len;

/*******************************************************************************/
/* I2C code part                                                               */
/* Read/write data on registers in the I2C connected RTC.                      */
/*******************************************************************************/

#define TW_START           0x08
#define TW_REPEATED_START  0x10
#define TW_MT_SLA_ACK      0x18
#define TW_MT_DATA_ACK     0x28
#define TW_MR_SLA_ACK      0x40
#define TW_MR_DATA_ACK     0x50
#define TW_MR_DATA_NOT_ACK 0x58

uint8_t I2C_RTC_Write(uint8_t rAddr, uint8_t N) {
    uint8_t i;

    TWCR = (1<<TWEN) | (1<<TWINT) | (1<<TWSTA);
    while (!(TWCR & (1<<TWINT)));
    if ((TWSR & 0xF8) != TW_START) return -1;

    TWDR = RTC_SLA;
    TWCR = (1<<TWEN) | (1<<TWINT);
    while (!(TWCR & (1<<TWINT)));
    if ((TWSR & 0xF8) != TW_MT_SLA_ACK) return -1;

    TWDR = rAddr;
    TWCR = (1<<TWEN) | (1<<TWINT);
    while (!(TWCR & (1<<TWINT)));
    if ((TWSR & 0xF8) != TW_MT_DATA_ACK) return -1;

    for (i = 0; i < N; i++) {
        TWDR = I2C_write_buffer[i];
        TWCR = (1<<TWEN) | (1<<TWINT);
        while (!(TWCR & (1<<TWINT)));
        if ((TWSR & 0xF8) != TW_MT_DATA_ACK) return -1;
    };

    TWCR = (1<<TWEN) | (1<<TWINT) | (1<<TWSTO);
    return 0;
}

uint8_t I2C_RTC_Read(uint8_t rAddr, uint8_t N) {
    uint8_t i;

    #ifdef I2C_DEBUG  // Code for Part B

    TWCR = (1<<TWEN) | (1<<TWINT) | (1<<TWSTA);
    PORTB = 1;
    while (!(TWCR & (1<<TWINT)));  // ca 40 us
    PORTB = 2;
    if ((TWSR & 0xF8) != TW_START) return -1;

    TWDR = RTC_SLA;
    TWCR = (1<<TWEN) | (1<<TWINT); // ca 10 us
    PORTB = 3;
    while (!(TWCR & (1<<TWINT))); // 326 us
    PORTB = 4;
    if ((TWSR & 0xF8) != TW_MT_SLA_ACK) return -1;

    TWDR = rAddr;
    TWCR = (1<<TWEN) | (1<<TWINT);
    // 9.9 us
    PORTB = 5;
    while (!(TWCR & (1<<TWINT)));  // 326 us
    PORTB = 6;
    if ((TWSR & 0xF8) != TW_MT_DATA_ACK) return -1;

    TWCR = (1<<TWEN) | (1<<TWINT) | (1<<TWSTA);
    // 8.9 us
    PORTB = 7;
    while (!(TWCR & (1<<TWINT))); // 60.5 us
    PORTB = 8;
    if ((TWSR & 0xF8) != TW_REPEATED_START) return -1;

    TWDR = RTC_SLA | 1;
    TWCR = (1<<TWEN) | (1<<TWINT);
    // 10.9 us
    PORTB = 9;
    while (!(TWCR & (1<<TWINT)));  // 326 us
    PORTB = 10;  // 19.9 us
    if ((TWSR & 0xF8) != TW_MR_SLA_ACK) return -1;

    for (i = 0; i < (N-1); i++) {
        TWCR = (1<<TWEN) | (1<<TWINT) | (1<<TWEA);
        PORTB = 11;
        while (!(TWCR & (1<<TWINT)));  // 325 us
        PORTB = 12;
        if ((TWSR & 0xF8) != TW_MR_DATA_ACK) return -1;
        I2C_read_buffer[i] = TWDR;
    };

    TWCR = (1<<TWEN) | (1<<TWINT);
    // 19.9 us
    PORTB = 13;
    while (!(TWCR & (1<<TWINT)));  // 326 us
    PORTB = 14;
    if ((TWSR & 0xF8) != TW_MR_DATA_NOT_ACK) return -1;
    I2C_read_buffer[(N-1)] = TWDR;

    // total 1730 us while loops
    // 1800 us total time
    // 96 % wasted

    #else    // Code for Part A

    TWCR = (1<<TWEN) | (1<<TWINT) | (1<<TWSTA);
    while (!(TWCR & (1<<TWINT)));
    if ((TWSR & 0xF8) != TW_START) return -1;

    TWDR = RTC_SLA;
    TWCR = (1<<TWEN) | (1<<TWINT);
    while (!(TWCR & (1<<TWINT)));
    if ((TWSR & 0xF8) != TW_MT_SLA_ACK) return -1;

    TWDR = rAddr;
    TWCR = (1<<TWEN) | (1<<TWINT);
    while (!(TWCR & (1<<TWINT)));
    if ((TWSR & 0xF8) != TW_MT_DATA_ACK) return -1;

    TWCR = (1<<TWEN) | (1<<TWINT) | (1<<TWSTA);
    while (!(TWCR & (1<<TWINT)));
    if ((TWSR & 0xF8) != TW_REPEATED_START) return -1;

    TWDR = RTC_SLA | 1;
    TWCR = (1<<TWEN) | (1<<TWINT);
    while (!(TWCR & (1<<TWINT)));
    if ((TWSR & 0xF8) != TW_MR_SLA_ACK) return -1;

    for (i = 0; i < (N-1); i++) {
        TWCR = (1<<TWEN) | (1<<TWINT) | (1<<TWEA);
        TWCR = (1<<TWEN) | (1<<TWINT) | (1<<TWEA);
        while (!(TWCR & (1<<TWINT)));
        if ((TWSR & 0xF8) != TW_MR_DATA_ACK) return -1;
        I2C_read_buffer[i] = TWDR;
    };

    TWCR = (1<<TWEN) | (1<<TWINT);
    while (!(TWCR & (1<<TWINT)));
    if ((TWSR & 0xF8) != TW_MR_DATA_NOT_ACK) return -1;
    I2C_read_buffer[(N-1)] = TWDR;

    #endif

    TWCR = (1<<TWEN) | (1<<TWINT) | (1<<TWSTO);
    return 0;
}

void I2C_init() {
    TWBR = 10;       // Set bit rate to f_clk/26 ~ 40 kbps
    TWSR = 0xf8;     // Set TWPS=0
    TWCR = (1<<TWEN);
}

/*******************************************************************************/
/* RTC code part                                                               */
/* Communicate with the RTC chip PCF8563 using the I2C bus.                    */
/*******************************************************************************/

void RTC_Reset() {
    I2C_write_buffer[0]  = 0x00; // CTRL/SR 1
    I2C_write_buffer[1]  = 0x00; // CTRL/SR 2
    I2C_write_buffer[2]  = 0x00; // Seconds
    I2C_write_buffer[3]  = 0x00; // Minutes
    I2C_write_buffer[4]  = 0x00; // Hours
    I2C_write_buffer[5]  = 0x10; // Days
    I2C_write_buffer[6]  = 0x03; // Weekdays
    I2C_write_buffer[7]  = 0x02; // Months
    I2C_write_buffer[8]  = 0x21; // Years

    I2C_write_buffer[9]  = 0x80; // Minute Alarm
    I2C_write_buffer[10] = 0x80; // Hour Alarm
    I2C_write_buffer[11] = 0x81; // Day Alarm
    I2C_write_buffer[12] = 0x80; // Weekday Alarm

    I2C_write_buffer[13] = 0x80; // CLKOUT CTRL

    I2C_write_buffer[14] = 0x00; // Timer CTRL
    I2C_write_buffer[15] = 0x00; // Timer
    I2C_RTC_Write(0, 16);
}

void RTC_init() {
    RTC_new_time_avail = 0;   // Clear received flag
    I2C_init();

    TCCR1A = 0x00;     // CTC Mode
    TCCR1B = 0x1d;     // CTC Mode , 1/1024 Prescaler
    ICR1   = 0x0400;   // approx. 1 Hz
    TIMSK  |= (1<<TICIE1);

}

void RTC_set_time() {
    //I2C_write_buffer[0] = DISP_value[0] & 0x0f;
    //I2C_write_buffer[0] = (DISP_value[1] & 0x07) << 4;
    //I2C_write_buffer[1] = DISP_value[2] & 0x0f;
    //I2C_write_buffer[1] = (DISP_value[3] & 0x07) << 4;

    I2C_write_buffer[0]  = 0x00; // CTRL/SR 1
    I2C_write_buffer[1]  = 0x00; // CTRL/SR 2
    I2C_write_buffer[2]  = DISP_value[0] & 0x0f | (DISP_value[1] & 0x07) << 4; // Seconds
    I2C_write_buffer[3]  = DISP_value[2] & 0x0f | (DISP_value[3] & 0x07) << 4; // Minutes
    I2C_RTC_Write(0, 4);
}

void RTC_received_new_time() {
    RTC_new_time_avail = 0;   // Clear received flag.
    DISP_value[0] = I2C_read_buffer[0] & 0x0f;
    DISP_value[1] = (I2C_read_buffer[0]>>4) & 0x07;
    DISP_value[2] = I2C_read_buffer[1] & 0x0f;
    DISP_value[3] = (I2C_read_buffer[1]>>4) & 0x07;
}

ISR(TIMER1_CAPT_vect) {  // One Second Pulse
    if (RTC_clock_on) {
        //sei();
        I2C_RTC_Read(2, 2); // starting at address 2, read 2 bytes.
        RTC_new_time_avail = 1;   // Set received flag.
    }
}

/*******************************************************************************/
/* Display code part                                                           */
/* Show DISP_value on a physical multiplexed 7-segment display module          */
/* Show DISP_alarm_value on a physical multiplexed 7-segment display module    */
/* The interrupt is trigged in 1 kHz, updating the "next" 7-seg.               */
/* The four 7-seg is updated in total of (1 kHz) / 4 = 250 Hz                  */
/*******************************************************************************/

void DISP_init() {
    DISP_value[0] = 0;
    DISP_value[1] = 0;
    DISP_value[2] = 0;
    DISP_value[3] = 0;
    DISP_mux = 0;

    DDRA = 0xff;       // All bits in port A are output
    DDRB = 0xff;       // All bits in port B are output
    DDRD |= 0x03;      // make PortD0 and D1 outputs. Do not engage the others.

    TCCR0 = 0x0a;      // CTC Mode , 1/8 Prescaler
    OCR0  = 124;       // approx. 1 kHz
    TIMSK  |= (1<<OCIE0);
}

const uint8_t DISP_Segment[] =
{0x3f, 0x06, 0x5b, 0x4f, 0x66, 0x6d, 0x7d, 0x07, 0x7f, 0x6f};

ISR(TIMER0_COMP_vect) {  // Display MUX
    uint8_t clock_pattern, alarm_pattern;
    if (DISP_mux >= (DISP_BUFF_SIZE-1)) {
        DISP_mux = 0;
        } else {
        DISP_mux++;
    };
    clock_pattern = DISP_Segment[DISP_value[DISP_mux]];
    if (DISP_mux == DISP_mark) {
        clock_pattern |= 0x80;  // Add a decimal dot to the output
    };

    #ifdef I2C_DEBUG  // Code for Part B

    PORTA = 0;
    PORTD = DISP_mux;
    PORTA = clock_pattern;

    #else  // Code for Part A

    PORTA = 0;
    PORTB = 0;
    PORTD = DISP_mux;
    PORTA = clock_pattern;
    PORTB = clock_pattern;

    #endif
}

/*******************************************************************************/
/* Keyboard code part                                                          */
/* The Keyboard strobe signal is triggering the INT1                           */
/* Keyboard data are transferred to KB_handle through a cyclic FIFO Buffer     */
/*******************************************************************************/

void KB_init() {
    // DDRD = 0;             // All bits in port D are input
    MCUCR |= 0x0c;        // Interrupt on rising edge.
    GIFR |= (1<<INTF1);   // Clear the INT1 interrupt flag, just in case.
    GICR |= (1<<INT1);    // External interrupt enable.
    KB_write_ptr = 0;     // Point to the next empty byte in FIFO
    KB_read_ptr = 0;      // Point to the next databyte in FIFO
    KB_queue_len = 0;     // Number of byte in FIFO
}

// Hex Keyboard, note that ISR(*) is "atomic" (cannot be interrupted)
ISR(INT1_vect) {
    uint8_t key;
    key = (PIND >> 4) & 0x0f;
    if (KB_queue_len < KB_BUFF_SIZE) {     // Check for buffer overflow
        KB_queue_len++;
        KB_FIFO[KB_write_ptr] = key;
        if (KB_write_ptr >= (KB_BUFF_SIZE-1)) {
            KB_write_ptr = 0;
            } else {
            KB_write_ptr++;
        };
    }
}

void KB_handle() {
    uint8_t key;
    key = KB_FIFO[KB_read_ptr];
    if (KB_read_ptr >= (KB_BUFF_SIZE-1)) {
        KB_read_ptr = 0;
        } else {
        KB_read_ptr++;
    };
    cli();
    KB_queue_len--;  // Atomic operation
    sei();
    switch (key) {
        case 0x0a:  // A: Save and Activate Alarm
        break;
        case 0x0b:  // B: Inactivate Alarm
        break;

        case 0x0d:  // D: Save New Time and continue to Set Clock Mode
            if (RTC_clock_on) {
                break;  // Unable to save new time in Clock Mode
            };
            RTC_set_time();
        case 0x0c:  // C: Set Clock Mode
        RTC_clock_on = 1;
        DISP_mark = 2;
        break;

        case 0x0e:  // E: Set Edit Mode
        RTC_clock_on = 0;
        DISP_mark = DISP_BUFF_SIZE-1;
        break;

        default:    // 0-9: Set value and continue to Move cursor
            if (RTC_clock_on) {
                break;  // Unable to input digits in Clock Mode
            }
            if ((DISP_mark % 2) && (key > 5)) {
                // 10-digitnumerals cant be higher than 5
                break;
            }
            DISP_value[DISP_mark] = key;
        case 0x0f:  // F: Move Cursor
        if (RTC_clock_on) {
            break;  // Unable to move cursor in Clock Mode
        };
        if (DISP_mark == 0) {
            DISP_mark = DISP_BUFF_SIZE-1;
        } else {
            DISP_mark--;
        };
        break;
    }
}

/*******************************************************************************/
/* Main                                                                        */
/*******************************************************************************/

int main(void){
    RTC_clock_on = 0;
    RTC_alarm_on = 0;
    RTC_alarm_signaled = 0;

    DISP_init();
    RTC_init();
    KB_init();

    sei();

    // Uncomment the following two lines when you are finished with the RTC_write_mode
    // function and if you want a reset of the RTC.
    RTC_Reset();

    RTC_clock_on = 1;
    DISP_mark = 2;

    while (1) {
        if (KB_queue_len > 0) {
            KB_handle();
        };
        if (RTC_new_time_avail) {
            RTC_received_new_time();
        }
    }
}
