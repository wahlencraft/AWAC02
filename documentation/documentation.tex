\documentclass{awac02}

% Packages
\usepackage[utf8]{inputenc}
\usepackage{tabularx}
\usepackage{graphicx}
\usepackage{svg}
\input{tikzconfig}

\title{Documentation}
\begin{document}

\maketitle

\section{Overview}

The documentation is meant as a guide for the developer. Additional aid is
found in the source header files where most functions are documented.

\section{Source Files}

In this section an overview of the project files are given.
The files are listed in order of relevance.

\begin{centering}
\vspace{3mm}
\begin{tabularx}{.9\textwidth}{ | >\raggedright p{5cm} | X | }
    \hline
    File(s)                  & Description \\ [0.5ex]
    \hline
    \texttt{main.c}                     & The main file. Contains the
                                          clock-mode state-machine.\\
    \texttt{constants.h}                & Global constants for defining number
                                          of displays, enabling logging etc. \\
    \texttt{menu.h}, \texttt{menu.c}    & The state machine for the menu. \\
    \texttt{utilities.h}, \texttt{utilities.c} & High level utilities. Mostly
                    for applying and showing settings. \\
    \texttt{log.h}, \texttt{log.c}      & Logging functions. Everything here
                                          will be unavailable if the LOG
                                          constant is undefined. \\
    \texttt{rtc.h}, \texttt{rtc.c}      & High level functions to set and show
                                          the external RTC clock. \\
    \texttt{display.h}, \texttt{display.c} & Low level functions to interface
                                             with the Qwiic Alphanumeric Display \\
    \texttt{user\_alarms.h}, \texttt{user\_alarms.c} & High level functions to
    find and modify alarms set by the user. \\
    \texttt{helpers.h}, \texttt{helpers.c} & Simple helper-functions. \\
    \texttt{external\_interrupts.h}, \texttt{external\_interrupts.S} &
                    Register and extract the external interrupts (button
                    presses and RTC alarms). \\
    \texttt{time.h}, \texttt{time.S}    & Start and use the hardware times. \\
    \texttt{twi.h}, \texttt{twi.S}      & Interface to the TWI (I2C) hardware.
                                          Read and write to external devices. \\
    \texttt{eeprom.h}, \texttt{eeprom.S} & Read and write to the EEPROM
                                           (non-volatile storage). \\
    \texttt{flash.h}, \texttt{flash.S}  & Read constant data from flash. For
                                          example an ASCII conversion table. \\
    \texttt{io.h}, \texttt{io.S}        & Direct control of pins. \\
    \texttt{usart.h}, \texttt{usart.S}  & Send data through USART. This is used
                                          to implement printf in `log.c` \\
    \texttt{math.S}                     & Low level math for assembly routines. \\
    \hline
\end{tabularx}
\end{centering}

\section{Schematic}

In figure \ref{fig:circuit} the circuit is shown. The value of R1-R7, C1 and C5-C7
is only approximate. You can try different values. In addition to these
components two Sparkfun Qwiic Alphanumeric Displays are used. One of the
displays must be modified to disable the pull-up resistors and change the slave
address to \texttt{0x71}.

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth, trim=5cm 5cm 6cm 2cm, clip]{../Circuit}
    \caption{The circuit (excluding displays).}
    \label{fig:circuit}
\end{figure}

\section{State Machine}

The state machine for clock mode is in \texttt{main.c} and the state machine
for the menu mode is in \texttt{menu.c}. They are implemented using the
\texttt{goto} statement which can lead to hard to understand code.  To give the
programmer a better overview of the states and make development easier some
states are documented here and shown in flow-charts. The program starts in the
\texttt{enter\_clock\_mode} state. The clock mode state machine is illustrated
in Figure \ref{fig:clock-state}.

\begin{figure}[h]
    \centering
    \input{clock-state}
    \caption{The clock mode state machine}
    \label{fig:clock-state}
\end{figure}

The menu mode state machine is a bit more complicated. A simple overview is
shown in Figure \ref{fig:menu-flowchart}. There are three basic state types in the
menu. \emph{Menu} states, \emph{choose} states and \emph{set} states. The menu
states are very simple. Each show some text on the display, then wait for a
button interrupt. If the \texttt{L} or \texttt{R} button is pressed the
state is changed to the previous or next menu state. If the \texttt{SP} button
is pressed it is changed to a choose or set state.

A choose state is used when there is multiple options for the setting that is
edited. For example when changing time. A choose state first shows the current
value of that setting, sets an RTC alarm for when it is changed and waits for
an interrupt. If the interrupt is from the RTC the new value is shown. If it is
from the \texttt{L} or \texttt{R} buttons the state changes to the previous or
next choose state. If it is from the \texttt{SP} button the state changes to
the corresponding set state.

A set state works a lot like a choose state. A RTC interrupt changes the value
shown and \texttt{SP} interrupt changes state (go back to the choose state).
But a \texttt{L} or \texttt{R} button interrupt de- or increments the value
instead.

Figure \ref{fig:choose-and-set-state} shows the program flow between a choose
and a set state in detail. The actual implementation varies slightly
between types.

\begin{figure}[h]
    \centering
    \input{choose-and-set-state}
    \caption{A choose and set state combo}
    \label{fig:choose-and-set-state}
\end{figure}

\begin{figure}[h]
    \centering
    \input{menu-flowchart}
    \label{fig:menu-flowchart}
    \caption{An overview of the menu}
\end{figure}

\section{EEPROM}

The ATmega328p has 1024 bytes non-volatile EEPROM storage. This space is used to
store user-made settings such as display brightness and alarms. This means that
this information will be available even after a power loss. The current time
will however be lost.

Low level EEPROM access is implemented in \texttt{eeprom.h} and
\texttt{eeprom.S}.

\subsection{User Alarms}
User alarms is the alarms set by the user with the time at which the buzzer
should sound. Not to be confused with RTC alarms which is interrupts triggered
by the RTC. User alarms are implemented
in \texttt{user\_alarms.h} and \texttt{user\_alarms.c}.

The user alarms are stored as an array with the element size of 2
bytes. Each element contains the day of the week, hour, minute and status of
the alarm. The element content is described by Table \ref{tab:user-alarm}.  In
addition to the elements, the array length $n$ is also stored in EEPROM. Note
that the array size is $2n$ bytes.

The array is not sorted. That means that the entire array needs to be traversed
to look for a match. However, the main performance consern is writes as one write
takes a very long time (around 3.3 ms). In Table
\ref{tab:user-alarm-performance} we see that deletes are particulary
problematic. Fortunatly deletes should be uncommon. Finding is the most common
operation and it does not require any writes.

\begin{table}[ht]
\centering
\begin{tabular}{| l | c | c | c | c |}
    \hline
    Data & Range & Bits & Byte & Notes\\
    \hline
    D.o.t.w. & 0-7 & 7-5 & high & 0 is all weekdays\\
    Hour & 0-23 & 4-0 & high & -\\
    Minute & 0-59 & 7-2 & low & -\\
    Status & 0-1 & 1 & low & 0 is off, 1 is on\\
    \hline
\end{tabular}
\caption{An user alarm}
\label{tab:user-alarm}
\end{table}

\begin{table}[ht]
\centering
\begin{tabular}{| l | c | c | c |}
    \hline
    Operation & Performance & Writes \\
    \hline
    Add item & $\mathcal{O}(1)$ & $3$ \\
    Find item & $\mathcal{O}(n)$ & $0$ \\
    Delete item & $\mathcal{O}(n)$ & $\leq 2n - 2$ \\
    Modify item & $\mathcal{O}(1)$ & $2$ \\
    \hline
\end{tabular}
\caption{User alarm performance analysis}
\label{tab:user-alarm-performance}
\end{table}

\end{document}
